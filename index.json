[{"categories":["技术"],"content":"安装 KubeVela需要一个K8S集群作为管控平台，Mac的个人开发环境下，最方便的是直接安装Docker Desktop。安装完成后，可以把其他K8S集群加入KubeVela进行管理。 注意：不要在个人环境下安装给线上提供服务的KubeVela管控平台/集群，稳定性和数据备份等都不完善 KubeVela vela install 注意：不支持arm架构（例如RaspberryPi），在执行到Jobkubevela-vela-core-admission-create时，Pod会提示错误信息standard_init_linux.go:228: exec user process caused: exec format error dashboard vela addon enable velaux serviceType=NodePort repo=acr.kubevela.net 如何访问 执行返回结果ENDPOINT有端口信息，在浏览器访问http://localhost:port即可 初始账号/密码 执行vela logs -n vela-system --name apiserver addon-velaux | grep \"initialized admin username\" 类似输出apiserver-655b77f8fd-l9tz8 apiserver 2022-05-19T07:40:35.530349180Z {\"level\":\"info\",\"ts\":1652946035.5300071,\"caller\":\"usecase/user.go:109\",\"msg\":\"initialized admin username and password: admin / o32v564hof\\n\"}，内容中admin是账号，o32v564hof是密码。 端口 因为Docker Desktop for Mac的docker0 bridge是运行在一个Linux的虚拟机中（参考官方文档Networking features），Host下无法直接访问容器（包括Kubernetes的Ingress）。但是可以通过Port Mapping的机制暴露到Host中，所以安装时使用NodePort作为serviceType。 ","date":"2022-10-26","objectID":"/kubevela-and-gitops/:0:1","tags":["KubeVela","Kubernetes","GitOps"],"title":"安装配置Kubevela和GitOps","uri":"/kubevela-and-gitops/"},{"categories":["技术"],"content":"配置 fluxcd 安装helm相关的应用需要依赖fluxcd这个addon，通过dashboard或命令行安装都可以 GitOps GitOps的前提是需要一个git仓库，为了方便在没有网络/无法访问公司仓库时·测试/调试，个人开发环境可以安装一个独立/轻量的git仓库服务。 gitea 执行vela up -f gitea.yaml安装。 关键参数 要能正常访问（原因见前面的dashboard的端口说明），Service需要配置nodePort service: http: nodePort: 30000 type: NodePort 监听git仓库 执行vela up -f infra.yaml安装。安装成功后，vela将自动监听git仓库变化自动同步K8S集群。 关键参数 仓库地址 gitea容器的服务端口是3000，注意因为fluxcd和gitea不在同一个namespace下，域名使用了服务的完整地址（服务的域名规则参考K8S的域名解析相关文档）。 # 将此处替换成你需要监听的 git 配置仓库地址 url: http://gitea-http.default.svc.cluster.local:3000/dev/docker-desktop.git ``` - 监听目录 根据实际情况填写路径 ``` # 监听变动的路径，指向仓库中 infra 目录下的文件 path: ./infra 完整yaml配置如下： ## gitea.yaml kind: Application apiVersion: core.oam.dev/v1alpha2 metadata: name: gitea spec: components: - name: gitea type: helm properties: repoType: helm url: 'https://dl.gitea.io/charts/' chart: gitea version: 5.0.0 values: gitea: config: cache: ADAPTER: memory ENABLED: true HOST: '127.0.0.1:9090' INTERVAL: 60 ingress: enabled: true hosts: - host: xxx paths: - path: / pathType: Prefix memcached: enabled: false persistence.size: 1Gi service: http: nodePort: 30000 type: NodePort ## infra.yaml apiVersion: core.oam.dev/v1beta1 kind: Application metadata: name: infra spec: components: - name: infra-source type: kustomize properties: repoType: git # 将此处替换成你需要监听的 git 配置仓库地址 url: http://gitea-http.default.svc.cluster.local:3000/dev/docker-desktop.git # 如果是私有仓库，还需要关联 git secret #secretRef: git-secret # 自动拉取配置的时间间隔，由于基础设施的变动性较小，此处设置为十分钟 pullInterval: 10m git: # 监听变动的分支 branch: master # 监听变动的路径，指向仓库中 infra 目录下的文件 path: ./infra ","date":"2022-10-26","objectID":"/kubevela-and-gitops/:0:2","tags":["KubeVela","Kubernetes","GitOps"],"title":"安装配置Kubevela和GitOps","uri":"/kubevela-and-gitops/"},{"categories":["技术"],"content":"配置GitOps 创建git仓库 打开gitea http://localhost:3000，第一个注册的账号是管理员。 新建一个git仓库，签名信任模型选择默认信任模型，这样可以匿名clone仓库，但是不能push代码。 clone仓库 git clone http://localhost:30000/gitdev/docker-desktop.git 备份集群相关代码 仓库根目录创建clusters，并把之前的gitea.yaml和infra.yaml添加到目录并提交。 增加其他应用 仓库根目录创建infra目录，然后根据需要（参考vela文档）增加即可。例如安装prometheus。 因为是虚拟机环境，注意配置helm的变量如下，否则无法正常启动prometheus-node-exporter。 values: nodeExporter: hostRootfs: false 完整代码 apiVersion: core.oam.dev/v1beta1 kind: Application metadata: name: prometheus spec: components: - name: prometheus type: helm properties: repoType: \"helm\" url: \"https://prometheus-community.github.io/helm-charts\" chart: \"prometheus\" version: \"15.8.7\" values: nodeExporter: hostRootfs: false ","date":"2022-10-26","objectID":"/kubevela-and-gitops/:0:3","tags":["KubeVela","Kubernetes","GitOps"],"title":"安装配置Kubevela和GitOps","uri":"/kubevela-and-gitops/"},{"categories":["技术"],"content":"补充 如何修改自定义域名 编辑 coredns 配置 kubectl -n kube-system edit configmap coredns 在data.Corefile内容中增加： hosts { 10.10.10.10 example.com fallthrough } 如何离线安装镜像 有些镜像需要翻墙才能正常访问，可以先找一个能访问的PC下载，然后离线安装到设备中 下载 能访问的PC通过pull命令即可下载。如何是下载ARM平台的，需要设置OS/ARCH参数，例如： docker pull --platform linux/arm/v7 k8s.gcr.io/kube-state-metrics/kube-state-metrics:v2.4.1 保存 docker save k8s.gcr.io/kube-state-metrics/kube-state-metrics:v2.4.1 -o kube-state-metrics-v2.4.1.tar.gz 安装 gz包上传到无法访问的设备，执行： docker import kube-state-metrics-v2.4.1.tar.gz 如果不是使用docker，而是cri，执行： ctr image import kube-state-metrics-v2.4.1.tar.gz ","date":"2022-10-26","objectID":"/kubevela-and-gitops/:0:4","tags":["KubeVela","Kubernetes","GitOps"],"title":"安装配置Kubevela和GitOps","uri":"/kubevela-and-gitops/"},{"categories":["技术"],"content":"树莓派的资源有限，不适合安装标准版的kubernetes，推荐在受限资源环境下使用的k3s，k3s是经过官方认证，完全兼容标准。 ","date":"2022-10-26","objectID":"/k8s-on-raspberrypi/:0:0","tags":["Kubernetes","树莓派"],"title":"在树莓派上运行Kubernetes","uri":"/k8s-on-raspberrypi/"},{"categories":["技术"],"content":"安装k3s 只有一个设备，只需安装简单配置的单机版即可，不需要安装更复杂配置的高可用版。详细完整的文档参考官方安装文档 前置依赖 使用Raspberry Pi OS时，有几个前置依赖需要先设置： 从nftables切换到iptables 执行命令 sudo iptables -F sudo update-alternatives --set iptables /usr/sbin/iptables-legacy sudo update-alternatives --set ip6tables /usr/sbin/ip6tables-legacy 启用cgroups 修改/boot/cmdline.txt，在现有内容的最后增加： cgroup_memory=1 cgroup_enable=memory 安装 k3s默认会安装为系统服务，重启也确保服务自动启动 最简方法 执行curl -sfL https://get.k3s.io | sh - 在线（国内加速）安装 由于k3s安装时是从github下载文件，没有安装翻墙代理时无法正常下载安装，参考官方（中文）文档，提供了国内加速安装的方法，很好的解决访问github需要翻墙问题。 curl -sfL http://rancher-mirror.cnrancher.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh - 离线安装 在一些特殊情况完全无法访问外部网络时，可以使用k3s提供的离线安装方式。 下载k3s二进制 官方下载地址，树莓派是下载k3s-armhf文件，选择最新稳定版本 下载k3s安装脚本 curl -sfL https://get.k3s.io -o install.sh 复制到树莓派 在PC电脑上执行 scp k3s-armhf pi@xxx.xxx.xxx.xxx:/home/pi/ scp install.sh pi@xxx.xxx.xxx.xxx:/home/pi/ 在树莓派上执行 chmod +x k3s-armhf \u0026\u0026 sudo cp /home/pi/k3s-armhf /usr/local/bin/k3s 安装 INSTALL_K3S_SKIP_DOWNLOAD=true /home/pi/install.sh ","date":"2022-10-26","objectID":"/k8s-on-raspberrypi/:0:1","tags":["Kubernetes","树莓派"],"title":"在树莓派上运行Kubernetes","uri":"/k8s-on-raspberrypi/"},{"categories":["技术"],"content":"配置k3s 配置外部kubectl/helm访问集群 详细参考官方文档 获取kubeconfig 树莓派默认用户pi没有权限访问系统目录，root用户默认是无法直接ssh登录，所以直接使用scp无法复制到本地，分两步： ssh pi@xxx.xxx.xxx.xxx 'sudo cp /etc/rancher/k3s/k3s.yaml /home/pi/ \u0026\u0026 sudo chown pi.pi /home/pi/k3s.yaml' scp pi@xxx.xxx.xxx.xxx:/home/pi/k3s.yaml ~/.kube/config 修改集群IP地址/机器名/域名 编辑本地~/.kube/config文件，找到内容server: https://127.0.0.1:6443，根据实际情况修改127.0.0.1为真实的IP地址（或者能使用机器名/域名访问树莓派时，也可以替换为机器名/域名） 验证 PC电脑上执行（需要先确保PC上已安装kubectl命令）kubectl get node，有类似输出： NAME STATUS ROLES AGE VERSION raspberrypi Ready control-plane,master 9m46s v1.22.5+k3s1 更换容器镜像源 参考k3s官方的配置containerd文档 复制配置文件 sudo cp /var/lib/rancher/k3s/agent/etc/containerd/config.toml /var/lib/rancher/k3s/agent/etc/containerd/config.toml.tmpl 修改config.toml.tmpl，添加如下内容，把默认的docker.io地址设置为镜像加速地址（这里选择了网易提供的镜像加速） [plugins.cri.registry.mirrors] [plugins.cri.registry.mirrors.\"docker.io\"] endpoint = [\"https://hub-mirror.c.163.com\",\"https://mirror.baidubce.com\"] 验证 重启k3s服务 sudo systemctl restart k3s 检查当前配置 crictl info|grep -A 7 registry，有类似输出： \"registry\": { \"mirrors\": { \"docker.io\": { \"endpoint\": [ \"https://hub-mirror.c.163.com\", \"https://mirror.baidubce.com\" ], ","date":"2022-10-26","objectID":"/k8s-on-raspberrypi/:0:2","tags":["Kubernetes","树莓派"],"title":"在树莓派上运行Kubernetes","uri":"/k8s-on-raspberrypi/"},{"categories":["技术"],"content":"安装Kubernetes Dashboard 详细参考k3s官方的Kubernetes Dashboard文档 前面已经配置好了外部kubectl/helm访问集群，就可以通过PC电脑方便的操作Kubernetes了，下面的操作在PC电脑上执行即可（需要先确保PC上已安装kubectl命令） 安装 GITHUB_URL=https://github.com/kubernetes/dashboard/releases VERSION_KUBE_DASHBOARD=$(curl -w '%{url_effective}' -I -L -s -S ${GITHUB_URL}/latest -o /dev/null | sed -e 's|.*/||') kubectl create -f https://raw.githubusercontent.com/kubernetes/dashboard/${VERSION_KUBE_DASHBOARD}/aio/deploy/recommended.yaml 添加管理用户 需要创建几个配置文件 dashboard.admin-user.yml apiVersion: v1 kind: ServiceAccount metadata: name: admin-user namespace: kubernetes-dashboard dashboard.admin-user-role.yml apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: admin-user roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: ServiceAccount name: admin-user namespace: kubernetes-dashboard 添加 kubectl create -f dashboard.admin-user.yml -f dashboard.admin-user-role.yml - 获取登录Token `kubectl -n kubernetes-dashboard describe secret admin-user-token | grep '^token'` 本地访问Dashboard 利用kubectl命令本身提供的代理功能，简单方便。 启动代理 kubectl proxy 默认使用8001端口，如果被其他服务占用，可以指定其他端口，例如： kubectl proxy --port=8010 浏览器访问 http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/ 注意端口8001要保持和启动代理的端口一致 登录 输入前面已经获取的Token即可 卸载 kubectl delete ns kubernetes-dashboard kubectl delete clusterrolebinding kubernetes-dashboard kubectl delete clusterrole kubernetes-dashboard ","date":"2022-10-26","objectID":"/k8s-on-raspberrypi/:0:3","tags":["Kubernetes","树莓派"],"title":"在树莓派上运行Kubernetes","uri":"/k8s-on-raspberrypi/"},{"categories":["技术"],"content":"简介 HomeAssiatant支持容器的运行方式，但是容器没有宕机重启的能力，如果出现异常退出，需要手工登录树莓派重启，操作比较麻烦。这时就可以利用kubernetes的能力了。 ","date":"2022-10-26","objectID":"/homeassisant-on-k8s/:0:1","tags":["Kubernetes","HomeAssistant"],"title":"如何在K8S中运行HomeAssisant","uri":"/homeassisant-on-k8s/"},{"categories":["技术"],"content":"安装 安装 kubectl apply -f home-assistant-deployment.yaml home-assistant-deployment.yaml内容如下： apiVersion: apps/v1 kind: Deployment metadata: labels: app.kubernetes.io/name: home name: home-assistant spec: replicas: 1 selector: matchLabels: app.kubernetes.io/name: home template: metadata: labels: app.kubernetes.io/name: home spec: hostNetwork: true containers: - image: ghcr.io/home-assistant/raspberrypi4-homeassistant:stable name: home-assistant ports: - containerPort: 8123 securityContext: privileged: true volumeMounts: - mountPath: /config name: ha-config volumes: - name: ha-config hostPath: path: /home/pi/ha-config 验证 等待一段时间（ha的镜像是在ghcr.io国外网站，下载需要较长时间），可以执行kubectl get pod查看pod home-assistant-xxx的输出信息，如果状态是Running就表示启动成功，例如： NAME READY STATUS RESTARTS AGE home-assistant-7b6f645b9b-fgbz7 0/1 Running 0 0m10s ","date":"2022-10-26","objectID":"/homeassisant-on-k8s/:0:2","tags":["Kubernetes","HomeAssistant"],"title":"如何在K8S中运行HomeAssisant","uri":"/homeassisant-on-k8s/"},{"categories":["技术"],"content":"远程访问 运行HomeAssiatant的Deployment时，指定了两个重要参数： 网络 hostNetwork: true，使用的是主机网络，也就是可以直接使用树莓派IP:port来访问HA服务。 权限 privileged: true，启动的HA服务有权限访问树莓派上的所有设备。这个非常重要，HA远程控制智能设备时需要访问wifi/bluetooth/usb等设备 打来浏览器访问树莓派的8213端口即可 ","date":"2022-10-26","objectID":"/homeassisant-on-k8s/:0:3","tags":["Kubernetes","HomeAssistant"],"title":"如何在K8S中运行HomeAssisant","uri":"/homeassisant-on-k8s/"},{"categories":["技术"],"content":"简介 支持FFmpeg 4.2版本 用decoder做示例： libavcodec/allcodecs.c extern AVCodec ff_h264_xxx_decoder; libavcodec/Makefile OBJS-$(CONFIG_H264_XXX_DECODER) += xxx.o yyy.o libavcodec/xxx.c yyy.c 代码实现 执行configure 新增一个codec（无论是decoder/encoder），必须执行一次。执行完成后，ffbuild/config.mak会自动添加CONFIG_H264_XXX_DECODER=yes，libavcodec/codec_list.c会自动添加\u0026ff_h264_xxx_decoder,，编译出来的ffmpeg才会有对应的codec。 以上只是结果，未深入分析configure脚本如果实现 编译结果 make后执行./ffmpeg -codecs |grep 264查询结果是否包含新的codec（AVCodec结构体对应的字段name） ","date":"2022-10-26","objectID":"/ffmpeg-codec/:0:1","tags":["FFmpeg"],"title":"FFmpeg如何添加一个Codec","uri":"/ffmpeg-codec/"},{"categories":["技术"],"content":"如何验证/测试 建议 ffmpeg本身静态编译（仅指静态链接libavxxx库，不含例如libx264等其它库），方便测试（不需要每次make install以及设置LD_LIBRARY_PATH） 例子（关键参数--pkg-config-flags=\"--static\"）： ./configure --prefix=./zy_build --pkg-config-flags=\"--static\" --extra-libs=\"-lpthread -lm -ldl -static-libgcc\" --enable-gpl --disable-libaom --enable-libx264 --enable-libx265 --enable-nonfree --disable-shared --enable-static --disable-ffplay --disable-ffprobe --disable-doc 如何验证解码器 指定使用自定义的解码器（dummy_h264_dec是解码器名，根据实际情况填写） ./ffmpeg -vcodec dummy_h264_dec -i video.264 -f rawvideo -an test.yuv -y video.264可以用标准版的ffmpeg+libx264生成 ffmpeg -ss 0 -t 1 -i video.mp4 -vcodec libx264 -pix_fmt yuv420p -an video.264 -y 播放yuv文件（1104x622是分辨率，根据实际情况填写） ffplay -f rawvideo -video_size 1104x622 -pixel_format yuv420p test.yuv 如何验证编码器 指定使用自定义的编码器（1104x622是分辨率/dummy_h264_enc是编码器名，根据实际情况填写） ./ffmpeg -s 1104x622 -r 25 -pix_fmt yuv420p -i video.yuv -an -vcodec dummy_h264_enc test.264 -y video.yuv可以用标准版的ffmpeg生成 ffmpeg -ss 0 -t 1 -i video.mp4 -vcodec rawvideo -pix_fmt yuv420p -an video.yuv -y 播放264文件 ffplay test.264 ","date":"2022-10-26","objectID":"/ffmpeg-codec/:0:2","tags":["FFmpeg"],"title":"FFmpeg如何添加一个Codec","uri":"/ffmpeg-codec/"},{"categories":["技术"],"content":"实现Codec FFmpeg的Codec框架 AVCodec AVCodec可以认为是FFmpeg编解码的类/结构定义，新增一个Codec（编码或解码）时，根据场景实现对应的回调函数即可。例子见下面encoder/decoder部分。 通用字段 .name/.long_name/.type/.id priv_data_size字段 AVCodec只是FFmpeg编解码的类/结构定义。Codec的具体实现是单独定义一个新的类/结构，用来封装/隔离FFmpeg运行时，一个Codec的多个实例的内部私有参数/变量。 在回调函数中，有一个公共参数：AVCodecContext *avctx，avctx-\u003epriv_data就是Codec实现类/结构的实例指针。因为C语言实现的一些细节，FFmpeg使用priv_data_size字段来定义实现类/结构的大小（以便用来分配实例的内存），例子： .priv_data_size = sizeof(XXXH264EncCtx), encoder 最小函数集合： .init，初始化 close，释放 encode2，编码 示例： typedef struct _DummyH264EncCtx { } DummyH264EncCtx; AVCodec ff_h264_dummy_encoder = { .name = \"dummy_h264_enc\", .long_name = NULL_IF_CONFIG_SMALL(\"Dummy H264 encoder\"), .type = AVMEDIA_TYPE_VIDEO, .id = AV_CODEC_ID_H264, .priv_data_size = sizeof(DummyH264EncCtx), .init = ff_dummy_h264_encode_init, .encode2 = ff_dummy_h264_encode_frame, .close = ff_dummy_h264_encode_close, }; decoder 最小函数集合： .init，初始化 close，释放 decode，解码 示例： typedef struct _DummyH264DecCtx { } DummyH264DecCtx; AVCodec ff_h264_dummy_decoder = { .name = \"dummy_h264_dec\", .long_name = NULL_IF_CONFIG_SMALL(\"Dummy H264 decoder\"), .type = AVMEDIA_TYPE_VIDEO, .id = AV_CODEC_ID_H264, .priv_data_size = sizeof(DummyH264DecCtx), .init = ff_dummy_h264_decode_init, .close = ff_dummy_h264_decode_close, .decode = ff_dummy_h264_decode_frame, }; 如何从FFmpeg命令行传递参数到Codec内部 参考文档 FFmpeg官方文档-AVOption FFmpeg源代码简单分析-AVOption AVClass和AVOption AVCodec的priv_class字段（类型是AVClass指针）结合FFmpeg的AVOption机制，能实现从FFmpeg命令行传递参数到Codec的内部实现类/结构。由于一些FFmpeg实现的细节，实际需要定义一个AVClass的类/结构，加上一个AVOption数组，实际的参数定义是在AVOption数组中实现。 AVOption的每项定义一个参数（并关联到Codec实现类/结构的字段）。第一个参数是FFmpeg命令行的参数名称，例如ffmpeg -i xxx -vcodec dummy_h264_enc -preset medium -dummy-params a=1:b=2 test.264（详细实现参考下面例子）。第三个参数关联Codec实现类/结构的字段，例如offsetof(DummyH264EncCtx, x)（详细实现参考下面例子）。 例子： AVCodec ff_h264_dummy_encoder = { //xxx .priv_class = \u0026dummy_h264_encoder_class, } static const AVClass dummy_h264_encoder_class = { .class_name = \"dummy_h264_enc\", .item_name = av_default_item_name, .option = dummy_h264_encoder_options, .version = LIBAVUTIL_VERSION_INT, }; #define OFFSET(x) offsetof(DummyH264EncCtx, x) #define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM static const AVOption dummy_h264_encoder_options[] = { { \"preset\", \"Set the encoding preset\", OFFSET(preset), AV_OPT_TYPE_STRING, { .str = \"medium\" }, 0, 0, VE}, { \"dummy-params\", \"Override configuration using a :-separated list of key=value parameters\", OFFSET(dummy_params), AV_OPT_TYPE_STRING, { 0 }, 0, 0, VE }, { NULL }, }; 编译时增加依赖库 执行./configure时，添加参数 编译参数（例如头文件路径/变量定义 ） --extra-cflags 链接参数（例如库文件路径/库） --extra-ldflags and --extra-libs ","date":"2022-10-26","objectID":"/ffmpeg-codec/:0:3","tags":["FFmpeg"],"title":"FFmpeg如何添加一个Codec","uri":"/ffmpeg-codec/"},{"categories":["技术"],"content":"安装 下载 wget https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh 安装 sudo ./install-release.sh 启动服务 systemctl enable v2ray \u0026\u0026 systemctl start v2ray ","date":"2022-10-26","objectID":"/v2ray/:0:1","tags":["V2Ray","科学上网"],"title":"安全上网工具V2Ray的安装配置","uri":"/v2ray/"},{"categories":["技术"],"content":"配置 WS + TLS这种更安全的方式，依赖web服务器和HTTPS的证书。 域名 域名服务商购买，并创建一个A记录类型，解析到自己的主机IP地址 证书 个人使用时，证书可以不签名，配置客户端时勾选transport setting-\u003eTLS-\u003eTLS allowInsecure 执行openssl命令： openssl req -x509 -subj \"/C=CN/ST=x/L=x/O=x/OU=x/CN=x\" -nodes -days 3650 -newkey rsa:2048 -keyout x.key -out x.crt 重要参数说明： 证书类型 -x509 证书过期时间 -days 3650 天 指定私钥输出文件 -keyout x.key 指定证书输出文件 -out x.crt 证书参数 /C国家 /ST省或州 /L城市 /O组织单位 /OU组织部门 CN通用名（一般填写域名） nginx 关键参数： server_name：x是占位符，需要修改为自己的域名 ssl_certificate和ssl_certificate_key：x是占位符，x.key/x.crt是前面步骤中的openssl生成 配置文件路径/etc/nginx/sites-enabled/x.conf，x是占位符，可以是任意有效文件名（建议用自己的域名），完整内容如下： server { listen 443 ssl; server_name x; ssl_certificate /etc/ssl/certs/x.crt; ssl_certificate_key /etc/ssl/private/x.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location /v2ray { proxy_redirect off; proxy_pass http://127.0.0.1:7879; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $http_host; } } ``` v2ray id可以使用uuidgen生成，配置文件/usr/local/etc/v2ray/config.json，完整内容如下（注：端口7879需要和nginx配置中一致）： { \"log\": { \"access\": \"/var/log/v2ray/access.log\", \"error\": \"/var/log/v2ray/error.log\", \"loglevel\": \"none\" }, \"inbounds\": [{ \"port\": 7879, \"protocol\": \"vmess\", \"settings\": { \"clients\": [{ \"id\": \"4BB35D9A-F164-4237-8FB9-4D3460F1556D\", \"level\": 0, \"alterId\": 0 } ] }, \"streamSettings\": { \"network\": \"ws\", \"wsSettings\": { \"path\": \"/v2ray\" } } } ], \"outbounds\": [{ \"protocol\": \"freedom\" } ] } ","date":"2022-10-26","objectID":"/v2ray/:0:2","tags":["V2Ray","科学上网"],"title":"安全上网工具V2Ray的安装配置","uri":"/v2ray/"},{"categories":["技术"],"content":"网络加速 在高延迟，高带宽 的网络环境下，可以开启BBR来加速网络。 开启 echo \"net.core.default_qdisc=fq\" | sudo tee --append /etc/sysctl.conf echo \"net.ipv4.tcp_congestion_control=bbr\" | sudo tee --append /etc/sysctl.conf sudo sysctl -p 确认 lsmod | grep bbr 输出tcp_bbr 20480 1表示成功 ","date":"2022-10-26","objectID":"/v2ray/:0:3","tags":["V2Ray","科学上网"],"title":"安全上网工具V2Ray的安装配置","uri":"/v2ray/"},{"categories":["技术"],"content":"EveryAsCode自动化脚本 前置依赖 参数 域名，必选参数 [client_id] client_id，可选参数。默认空时会自动生成一个新的UUID作为client id 例子： sudo ./v2ray-ws+tls-install.sh v2ray.yourdomain.com 4E2D399A-5029-4440-ACA1-7E297FD80EC3 Toolchain apt，nginx，openssl，sysctl，systemctl，unzip 默认nginx，unzip未安装，脚本执行时会自动安装 脚本v2ray-ws+tls-install.sh #!/bin/bash function log_info() { echo -e \"\\033[32m$@\\033[0m\" } function log_warn() { echo -e \"\\033[33m$@\\033[0m\" } function log_error() { echo -e \"\\033[31m$@\\033[0m\" } function main() { local domain=$1 local client_id=$2 if [ -z $client_id ]; then client_id=$(uuidgen) fi log_info 'installing v2ray' systemctl is-enabled v2ray 2\u003e/dev/null if [ $? -ne 0 ]; then wget https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh -o install-release.sh if [ $? -ne 0 ]; then log_error ' download v2ray error' return 1 fi if ! type $cmd \u003e/dev/null 2\u003e\u00261; then apt install unzip -y if [ $? -ne 0 ]; then log_error ' install unzip error' return 1 fi fi chmod +x install-release.sh \u0026\u0026 ./install-release.sh if [ $? -ne 0 ]; then log_error ' install v2ray error' return 1 fi else log_warn ' v2ray has installed' fi log_info 'enabling v2ray service' systemctl enable v2ray if [ $? -ne 0 ]; then log_error ' enable v2ray service error' return 1 fi log_info 'configuring ws+tls' log_info ' generating openssl cert' openssl req -x509 -subj '/C=CN/ST=x/L=x/O=x/OU=x/CN=x' -nodes -days 3650 -newkey rsa:2048 -keyout $domain.key -out $domain.crt if [ $? -ne 0 ]; then log_error ' generate ssl certificate error' return 1 fi cp v2r.afterain.cc.crt /etc/ssl/certs/v2r.afterain.cc.crt cp v2r.afterain.cc.key /etc/ssl/private/v2r.afterain.cc.key log_info ' installing nginx' if ! type $cmd \u003e/dev/null 2\u003e\u00261; then apt install nginx -y if [ $? -ne 0 ]; then log_error ' install nginx error' return 1 fi fi log_info ' configuring nginx' cat \u003c\u003cEOF | tee /etc/nginx/sites-enabled/$domain.conf 2\u003e\u00261 1\u003e/dev/null server { listen 443 ssl; server_name $domain; ssl_certificate /etc/ssl/certs/$domain.crt; ssl_certificate_key /etc/ssl/private/$domain.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location /v2ray { proxy_redirect off; proxy_pass http://127.0.0.1:7879; proxy_http_version 1.1; proxy_set_header Upgrade \\$http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host \\$http_host; } } EOF log_info 'configuring v2ray' cat \u003c\u003cEOF | tee /usr/local/etc/v2ray/config.json 2\u003e\u00261 1\u003e/dev/null { \"log\": { \"access\": \"/var/log/v2ray/access.log\", \"error\": \"/var/log/v2ray/error.log\", \"loglevel\": \"none\" }, \"inbounds\": [{ \"port\": 7879, \"protocol\": \"vmess\", \"settings\": { \"clients\": [{ \"id\": \"$client_id\", \"level\": 0, \"alterId\": 0 } ] }, \"streamSettings\": { \"network\": \"ws\", \"wsSettings\": { \"path\": \"/v2ray\" } } } ], \"outbounds\": [{ \"protocol\": \"freedom\" } ] } EOF log_info 'starting bbr' grep 'net.core.default_qdisc=fq' /etc/sysctl.conf if [ $? -ne 0 ]; then echo 'net.core.default_qdisc=fq' | tee --append /etc/sysctl.conf fi grep 'net.ipv4.tcp_congestion_control=bbr' /etc/sysctl.conf if [ $? -ne 0 ]; then echo 'net.ipv4.tcp_congestion_control=bbr' | tee --append /etc/sysctl.conf fi sysctl -p 2\u003e\u00261 1\u003e/dev/null if [ $? -ne 0 ]; then log_error ' start bbr error' return 1 fi log_info 'restarting service' log_info ' restarting nginx service' systemctl restart nginx if [ $? -ne 0 ]; then log_error ' restart nginx error' return 1 fi log_info ' restarting v2ray service' systemctl restart v2ray if [ $? -ne 0 ]; then log_error ' restart v2ray error' return 1 fi log_info 'v2ray connfigure info:' log_info \" address: $domain\" log_info \" port: 443\" log_info \" client id: $client_id\" log_info \" transport-\u003enetwork: ws\" log_info \" transport-\u003epath: /v2ray\" log_info \" transport-\u003etls: Use TLS\" log_info \" transport-\u003etls-\u003eallowInsecure: true\" log_info \" transport-\u003etls-\u003eallowInsecure: true\" log_info \" transport-\u003etls-\u003eserverName: $domain\" } if [ -n \"$BASH_SOURCE\" -a \"$BASH_SOURCE\" == \"$0\" ]; then if [ \"$(id -u)\" != \"0\" ]; then log_error ","date":"2022-10-26","objectID":"/v2ray/:0:4","tags":["V2Ray","科学上网"],"title":"安全上网工具V2Ray的安装配置","uri":"/v2ray/"},{"categories":["技术"],"content":"安装 选择区域 Tokyo, Zone A (ap-northeast-1a) 选择系统 Platform： Linux blueprint： OS Only =\u003e Debian 11.4 选择配置/费用 配置：1vCPU/512MB 流量：1TB流量 注意流量的规则较为复杂：流量=输入+输出 所以在代理方式使用场景下，相当于实际512GB流量 折算为7x24小时不间断使用带宽=512*1000/30/86400*8～=1.58Mbps，个人使用基本够用 超出流量后： 输入的免费（相当于lightsail从外部下载的内容） 输出的额外收费（相当于代理从lightsail下载的内容） 所以超出的流量实际相当于半价 费用：3.5$/月 ","date":"2022-10-26","objectID":"/lightsail/:0:1","tags":["AWS","科学上网"],"title":"安装配置lightsail","uri":"/lightsail/"},{"categories":["技术"],"content":"配置防火墙 开放端口： 22/80/443 默认已经开放22和80端口，只需要新增443端口即可 ","date":"2022-10-26","objectID":"/lightsail/:0:2","tags":["AWS","科学上网"],"title":"安装配置lightsail","uri":"/lightsail/"},{"categories":["技术"],"content":"SSH登陆 系统的SSH默认配置不允许密码登陆，需要先下载私钥 默认账号admin，ssh admin@xxx ","date":"2022-10-26","objectID":"/lightsail/:0:3","tags":["AWS","科学上网"],"title":"安装配置lightsail","uri":"/lightsail/"},{"categories":["技术"],"content":"其他 根据实际需要安装代理等 ","date":"2022-10-26","objectID":"/lightsail/:0:4","tags":["AWS","科学上网"],"title":"安装配置lightsail","uri":"/lightsail/"},{"categories":["技术"],"content":"EveryAsCode自动化脚本 lightsail支持CLI和API 前置依赖 用户 从安全考虑，为自动化创建lightsail实例新建专用账号 权限 创建专用policy，只赋予必要权限。这样即使不小心泄漏了用户的AK，也不会造成太大的危害 创建实例和配置防火墙权限： lightsail:CreateInstances lightsail:OpenInstancePublicPorts 查询系统（blueprint）和配置（bundle）权限： lightsail:GetBlueprints lightsail:GetBundles SSH Key 如果不使用默认SSH Key，可以创建一个 Toolchain AWS CLI 执行aws configure配置Access Key ID，Secret Access Key和Default region name（ap-northeast-1） 脚本create-lightsail.sh #!/bin/bash INSTANCE_NAME='debian-11-v2ray' ret=$(aws lightsail get-instance --no-cli-pager \\ --instance-name $INSTANCE_NAME | grep 'NotFoundException') if [ ! -z $ret ]; then aws lightsail create-instances --no-cli-pager \\ --instance-names $INSTANCE_NAME \\ --availability-zone ap-northeast-1a \\ --blueprint-id debian_11 \\ --bundle-id nano_2_0 \\ --ip-address-type ipv4 \\ --key-pair-name macbook-pro if [ $? -ne 0 ]; then echo -e \"\\033[31mcreate instance error\\033[0m\" exit 1 fi else echo -e \"\\033[32m$INSTANCE_NAME is exist\\033[0m\" fi aws lightsail open-instance-public-ports --no-cli-pager \\ --instance-name $INSTANCE_NAME \\ --port-info fromPort=443,protocol=TCP,toPort=443 if [ $? -ne 0 ]; then echo -e \"\\033[31mopen public port 443 error\\033[0m\" exit 1 fi echo -n -e \"\\033[32mpublic ip:\\033[0m\" aws lightsail get-instance --no-cli-pager \\ --instance-name $INSTANCE_NAME \\ | grep publicIpAddress | awk '{print $2}' | awk -F ',' '{print $1}' ","date":"2022-10-26","objectID":"/lightsail/:0:5","tags":["AWS","科学上网"],"title":"安装配置lightsail","uri":"/lightsail/"},{"categories":["技术"],"content":"什么是GitHub Pages GitHub Pages是通过git仓库来管理个人或项目网站。 优势 文章不丢失 使用git（分布式代码管理工具）管理文章内容，能安全可靠的保存文章，以及所有的历史变更记录。 免维护工作和无成本 避免个人网站的各种维护工作和成本 成本：购买服务器/带宽/存储等费用 维护工作：https证书申请/轮换，网站安全，系统管理等等 自定义域名 很多blog服务也能保证文章丢失，也不需要维护工作和成本，但是很少支持使用自己的自定义域名。这个能让网站看起来是一个独立的个人网站，和Github完全无关。 劣势 不支持动态网站 如果只是用来写文章/记录各种心得，静态网站能完全满足需求。但是如果需要实验建站的各种前后端技术，就不太适合了。 ","date":"2022-10-25","objectID":"/githubpages/:0:1","tags":["建站"],"title":"使用GitHub免费搭建个人网站","uri":"/githubpages/"},{"categories":["技术"],"content":"如何使用GitHub Pages 关键步骤 注册github账号 创建git仓库 注意仓库名必须是username.github.io形式，username是GitHub的用户名 编辑内容 主页文件：index.html 先通过git clone代码仓库，然后创建/编辑文件，最后在提交代码成功时，会自动发布到网站 自定义域名 需要先在自己的域名提供商中配置： 增加解析 记录类型： CNAME 主机记录： @ （直接解析主域名，例如github.io） 记录值： username.github.io （username替换为GitHub的用户名） 如果需要解析例如www.github.io，则在增加一条解析，其他参数相同，主机记录设置为： www 即可。 详细文档以及GitHub本身的配置参考GitHub Pages配置文档 基本过程是在对应的git仓库中设置，链接：https://github.com/usename/usename.github.io/settings/pages（username替换为GitHub的用户名） 分支 默认是main 域名 填写自己的域名 HTTPS 勾选Enforce HTTPS，不能通过HTTP访问，强制设置为HTTPS访问。 ","date":"2022-10-25","objectID":"/githubpages/:0:2","tags":["建站"],"title":"使用GitHub免费搭建个人网站","uri":"/githubpages/"},{"categories":["技术"],"content":"静态网站工具 静态网站的工具非常多，例如GitHub官方支持的Jekyll，还有Hugo/Hexo/VuePress/Nuxt.js等。 每个工具的使用方法各有特色，但是基本原理都是有一个build步骤，把内容编译成html/js/css文件，并输出到一个public目录。然后把http服务的根目录设置为public目录即可访问。 ","date":"2022-10-25","objectID":"/githubpages/:0:3","tags":["建站"],"title":"使用GitHub免费搭建个人网站","uri":"/githubpages/"},{"categories":["技术"],"content":"静态网站工具如何结合GitHub Pages GitHub支持workflows的功能，能在提交代码后自动执行指定的任务。只要把任务配置为静态网站工具的build就能自动发布内容了。 以Hugo工具为例，详细参考Host on GitHub 设置任务 先在git仓库的根目录的.github/workflows新建gh-pages.yml文件，内容如下： name: github pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-22.04 steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == 'refs/heads/main' with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 修改GitHub Pages配置 上面设置的任务中，实际是把main分支的内容，经过Hogo的build，把public下所有内容重新提交到gh-pages分支根目录下。所以只要把GitHub Pages配置中的分支参数修改为： gh-pages，即可以实现提交代码自动发布到网站的功能。 ","date":"2022-10-25","objectID":"/githubpages/:0:4","tags":["建站"],"title":"使用GitHub免费搭建个人网站","uri":"/githubpages/"},{"categories":null,"content":"AFTERAIN ","date":"2022-09-29","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["技术"],"content":"安装系统 下载 操作系统镜像 树莓派有很多发行版，官方支持的Raspberry Pi OS就有多个版本（桌面版本，桌面版本+推荐软件，精简版）可供选择。场景是用树莓派做服务器，不连接显示器/键盘/鼠标，所以选择的精简版。 下载安装程序Raspberry Pi Imager 安装程序运行在PC电脑上，支持在windows/Ubuntu/macOS多种操作系统下使用。 安装 Raspberry Pi Imager只要3步就能把操作系统写入SD卡：选择 操作系统镜像 -\u003e 选择 SD卡 -\u003e 写入 分区 安装程序在SD卡上创建了两个分区：boot(启动)分区和root(系统)根分区 boot包含了启动最关键的linux内核文件。分区是vfat格式。现在常用的PC操作系统windows/Linux/macOS都能直接访问（读写文件） root包含了除内核之外，操作系统的各种文件（二进制/配置等），分区是ext4格式。Linux各种发行版默认都支持ext4格式，但是大家常用的windows/macOS系统PC电脑是无法直接访问的（需要安装特殊软件才支持）。 所以安装完成后，如果把SD卡重新插入PC电脑，windows/macOS只能看到一个boot磁盘。 ","date":"2022-09-29","objectID":"/raspberrypi/:0:1","tags":["树莓派"],"title":"安装配置RaspberryPi","uri":"/raspberrypi/"},{"categories":["技术"],"content":"无显示器启动时的配置机制 其实在安装系统完成后，只需要把SD卡插入树莓派中，接通电源即可启动系统使用了。不过由于不接显示器/键盘/鼠标，所以需要在启动前先配置好网络和SSH服务（远程登录控制），否则无法使用。 由于大家常用的windows/macOS系统PC电脑无法直接访问root分区，也就无法修改配置文件。这时树莓派提供了一个有趣的方案，只要在boot分区按照规范的文件名和格式创建好相关配置，就会在启动时自动加载。具体支持哪些，参考官方配置文档。 后面的wifi配置和SSH服务都使用了这个机制。 ","date":"2022-09-29","objectID":"/raspberrypi/:0:2","tags":["树莓派"],"title":"安装配置RaspberryPi","uri":"/raspberrypi/"},{"categories":["技术"],"content":"配置wifi网络 配置文件 在boot磁盘的根目录创建文件wpa_supplicant.conf ,内容如下： country=CN ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 network={ ssid=\"xxx\" psk=\"yyy\" key_mgmt=WPA-PSK priority=1 } 根据实际情况修改ssid（wifi网络名）和psk（wifi密码）两个参数即可。其实key_mgmt也需要根据实际情况修改，不过考虑安全性，家庭wifi一般都推荐使用WPA-PSK。 如何获取IP地址 启动树莓派后，登录路由器，查看客户端名称是raspberrypi的IP地址即可。 最好使用路由器提供的“手工指定IP地址”的方法，给树莓派一个固定的IP。一般需要先在路由器查询已DHCP分配的客户端列表，找到raspberrypi对应的MAC地址，然后进行设置。 这样树莓派就可以作为固定IP地址的服务器使用了。 ","date":"2022-09-29","objectID":"/raspberrypi/:0:3","tags":["树莓派"],"title":"安装配置RaspberryPi","uri":"/raspberrypi/"},{"categories":["技术"],"content":"配置SSH服务 在boot磁盘的根目录创建文件ssh或ssh.txt，文件内容为空即可。这样树莓派启动时会开启SSH服务，默认的账号是pi，密码是raspberry。 ","date":"2022-09-29","objectID":"/raspberrypi/:0:4","tags":["树莓派"],"title":"安装配置RaspberryPi","uri":"/raspberrypi/"},{"categories":["技术"],"content":"更改apt源 SSHssh pi@xxx.xxx.xxx.xxx登录树莓派，输入默认密码raspberry 修改文件etc/apt/sources.list（改为清华提供的源），内容如下： deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib 执行apt-get update更新源信息 ","date":"2022-09-29","objectID":"/raspberrypi/:0:5","tags":["树莓派"],"title":"安装配置RaspberryPi","uri":"/raspberrypi/"}]